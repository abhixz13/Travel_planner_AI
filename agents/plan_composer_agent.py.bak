# agents/plan_composer_agent.py (Updated with Phase 1 Integration)
"""
AI-driven Plan Composer - Generates complete day-by-day itinerary
NOW WITH: Component registration and context tracking
"""

from __future__ import annotations
from typing import Dict, Any, List, Tuple
import logging
import re
from core.state import GraphState
from core.conversation_manager import handle_ai_output
from core.component_registry import register_component
from core.context_tracker import update_context
from langchain_openai import ChatOpenAI

logger = logging.getLogger(__name__)


def _gather_trip_facts(state: GraphState) -> Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any], Dict[str, Any]]:
    """Collect trip facts and research results."""
    plan: Dict[str, Any] = state.get("current_plan", {}) or {}
    ex: Dict[str, Any] = state.get("extracted_info", {}) or {}

    plan_summary: Dict[str, Any] = plan.get("summary", {}) if isinstance(plan.get("summary"), dict) else {}

    dates_block = plan_summary.get("dates") if isinstance(plan_summary.get("dates"), dict) else {}
    dep = dates_block.get("departure") if dates_block else None
    ret = dates_block.get("return") if dates_block else None
    dur = dates_block.get("duration_days") if dates_block else None

    facts = {
        "origin": plan_summary.get("origin") or ex.get("origin") or "",
        "destination": plan_summary.get("destination") or ex.get("destination") or "",
        "destination_hint": ex.get("destination_hint") or "",
        "duration_days": plan_summary.get("duration_days") or ex.get("duration_days") or dur or 2,
        "purpose": plan_summary.get("purpose") or ex.get("trip_purpose") or "",
        "pack": plan_summary.get("pack") or ex.get("travel_pack") or "",
        "dates": {
            "departure": dep or ex.get("departure_date") or "",
            "return": ret or ex.get("return_date") or "",
        },
    }

    def _extract_research(name: str) -> Dict[str, Any]:
        raw = plan.get(name)
        block = raw if isinstance(raw, dict) else {}
        recommendations = str(block.get("recommendations", "") or block.get("summary", "") or "").strip()
        sources_raw = block.get("sources") or block.get("results")
        sources: List[Dict[str, str]] = []
        if isinstance(sources_raw, list):
            for item in sources_raw:
                if not isinstance(item, dict):
                    continue
                url = str(item.get("url", "") or "").strip()
                if not url:
                    continue
                title = str(item.get("title", "") or "").strip() or "Link"
                sources.append({"title": title, "url": url})
                if len(sources) >= 4:
                    break
        return {"recommendations": recommendations, "sources": sources}

    travel = _extract_research("travel")
    stays = _extract_research("stays")
    acts = _extract_research("activities")

    logger.debug(
        "Composer gathered: destination=%s, duration=%s days, travel_sources=%d, stay_sources=%d, activity_sources=%d",
        facts.get("destination") or facts.get("destination_hint"),
        facts.get("duration_days"),
        len(travel["sources"]),
        len(stays["sources"]),
        len(acts["sources"]),
    )

    return facts, travel, stays, acts


def _parse_and_register_components(state: GraphState, itinerary_text: str, facts: Dict[str, Any]) -> None:
    """
    Parse the generated itinerary and register structured components.
    This enables future refinement capabilities.
    """
    logger.debug("Parsing itinerary to register components...")
    
    # Register metadata
    state["itinerary_components"]["metadata"] = {
        "destination": facts.get("destination", ""),
        "origin": facts.get("origin", ""),
        "dates": facts.get("dates", {}),
        "duration_days": facts.get("duration_days", 2),
        "purpose": facts.get("purpose", ""),
        "pack": facts.get("pack", "")
    }
    
    # Parse and register hotels (from ## üè® Where to Stay section)
    hotel_section = _extract_section(itinerary_text, r'##\s*üè®\s*Where to Stay')
    if hotel_section:
        hotels = _parse_hotels(hotel_section)
        if hotels:
            # Register first hotel as primary accommodation
            primary_hotel = hotels[0]
            register_component(
                state,
                component_data={
                    "name": primary_hotel.get("name", "Hotel"),
                    "description": primary_hotel.get("description", ""),
                    "price_range": primary_hotel.get("price", ""),
                    "features": primary_hotel.get("features", []),
                    "alternatives": hotels[1:] if len(hotels) > 1 else []
                },
                component_type="accommodation"
            )
            logger.debug(f"Registered accommodation: {primary_hotel.get('name')}")
    
    # Parse and register daily activities
    day_sections = _extract_day_sections(itinerary_text)
    for day_num, day_content in day_sections.items():
        logger.debug(f"Parsing Day {day_num}...")
        
        # Parse time slots
        time_slots = _parse_time_slots(day_content)
        
        for slot_name, slot_content in time_slots.items():
            activities = _parse_activities(slot_content)
            
            for activity in activities:
                component_id = register_component(
                    state,
                    component_data={
                        "name": activity.get("name", "Activity"),
                        "description": activity.get("description", ""),
                        "time": activity.get("time", ""),
                        "duration": activity.get("duration", ""),
                        "cost": activity.get("cost", ""),
                        "type": activity.get("type", "activity"),
                        "tips": activity.get("tips", [])
                    },
                    component_type=activity.get("type", "activity"),
                    day_number=day_num,
                    time_slot=slot_name
                )
                logger.debug(f"Registered Day {day_num} {slot_name}: {activity.get('name')} [{component_id}]")
    
    logger.debug("Component registration complete.")


def _extract_section(text: str, header_pattern: str) -> str:
    """Extract content between a header and the next header."""
    match = re.search(header_pattern, text, re.IGNORECASE)
    if not match:
        return ""
    
    start = match.end()
    # Find next ## header
    next_header = re.search(r'\n##\s', text[start:])
    end = start + next_header.start() if next_header else len(text)
    
    return text[start:end].strip()


def _parse_hotels(section: str) -> List[Dict[str, Any]]:
    """Parse hotel recommendations from text."""
    hotels = []
    # Look for **Hotel Name** patterns
    hotel_pattern = r'\*\*([^*]+?)\*\*\s*[-‚Äì‚Äî]\s*([^*\n]+)'
    matches = re.findall(hotel_pattern, section)
    
    for name, description in matches:
        # Try to extract price
        price_match = re.search(r'\$\d+[-‚Äì/]\s*(?:night|per night)', description, re.IGNORECASE)
        price = price_match.group(0) if price_match else ""
        
        hotels.append({
            "name": name.strip(),
            "description": description.strip(),
            "price": price
        })
    
    return hotels


def _extract_day_sections(text: str) -> Dict[int, str]:
    """Extract individual day sections."""
    days = {}
    day_pattern = r'###\s*Day\s*(\d+)\s*[-‚Äì‚Äî]?\s*[^\n]*\n((?:(?!###\s*Day).)*)'
    matches = re.finditer(day_pattern, text, re.DOTALL | re.IGNORECASE)
    
    for match in matches:
        day_num = int(match.group(1))
        content = match.group(2).strip()
        days[day_num] = content
    
    return days


def _parse_time_slots(day_content: str) -> Dict[str, str]:
    """Parse time slots within a day."""
    slots = {}
    slot_pattern = r'\*\*\s*(Morning|Afternoon|Evening)\s*(?:\([^)]+\))?\s*\*\*\s*((?:(?!\*\*(?:Morning|Afternoon|Evening)).)*)'
    matches = re.finditer(slot_pattern, day_content, re.DOTALL | re.IGNORECASE)
    
    for match in matches:
        slot_name = match.group(1).lower()
        content = match.group(2).strip()
        slots[slot_name] = content
    
    return slots


def _parse_activities(slot_content: str) -> List[Dict[str, Any]]:
    """Parse activities from a time slot."""
    activities = []
    
    # Look for bullet points or numbered items
    lines = slot_content.split('\n')
    current_activity = None
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
        
        # Check if this is a new activity (starts with - or number)
        if re.match(r'^[-‚Ä¢*]\s*\d+[:.]\d+\s*(?:AM|PM)?', line, re.IGNORECASE):
            # Time-prefixed activity
            if current_activity:
                activities.append(current_activity)
            
            # Extract time and name
            time_match = re.match(r'^[-‚Ä¢*]\s*(\d+[:.]\d+\s*(?:AM|PM)?)[:\s]+([^(]+)', line, re.IGNORECASE)
            if time_match:
                current_activity = {
                    "time": time_match.group(1).strip(),
                    "name": time_match.group(2).strip(),
                    "description": line,
                    "type": "activity"
                }
                
                # Detect type
                if any(word in line.lower() for word in ["dinner", "lunch", "breakfast", "restaurant", "cafe"]):
                    current_activity["type"] = "restaurant"
        
        elif current_activity:
            # Additional description for current activity
            current_activity["description"] += " " + line
    
    if current_activity:
        activities.append(current_activity)
    
    return activities


def compose_itinerary(state: GraphState) -> GraphState:
    """Generate a complete day-by-day itinerary with AI recommendations."""
    facts, travel, stays, acts = _gather_trip_facts(state)

    context = {
        "trip": facts,
        "research": {
            "travel": travel,
            "stays": stays,
            "activities": acts,
        },
    }

    system_prompt = (
        "You are an expert travel planner creating a complete, actionable itinerary.\n\n"
        "STRUCTURE YOUR RESPONSE AS:\n\n"
        "# üó∫Ô∏è Your [Destination] Adventure\n"
        "[Brief enthusiastic intro]\n\n"
        "## üìç Trip Overview\n"
        "- Origin ‚Üí Destination\n"
        "- Dates & Duration\n"
        "- Travel party\n\n"
        "## üöó Getting There\n"
        "[Synthesize travel recommendations into actionable advice]\n"
        "- If driving: estimated time, route tips\n"
        "- If flying: airport recommendations, flight options\n"
        "Include 2-3 reference links\n\n"
        "## üè® Where to Stay\n"
        "[Provide 2-3 SPECIFIC hotel/area recommendations with WHY they're good]\n"
        "Format as: **Hotel Name** - Brief description, family features, location benefits\n"
        "Include 2-3 reference links\n\n"
        "## üìÖ Day-by-Day Itinerary\n\n"
        "### Day 1 - [Theme]\n"
        "**Morning (9am-12pm)**\n"
        "- 9:00 AM: [Specific activity with details]\n"
        "- Practical tips\n\n"
        "**Afternoon (12pm-5pm)**\n"
        "- 12:30 PM: [Activity]\n"
        "- Tips\n\n"
        "**Evening (5pm+)**\n"
        "- 6:00 PM: [Dinner/activity recommendation]\n\n"
        "[Repeat for each day]\n\n"
        "## üí° Pro Tips\n"
        "- [3-5 specific, actionable tips for this trip]\n\n"
        "## üîó Additional Resources\n"
        "[Activity reference links]\n\n"
        "---\n"
        "**Ready to refine your plan?** Tell me if you'd like to adjust the pace, swap activities, or focus on specific interests!\n\n"
        "CRITICAL RULES:\n"
        "- Create a COMPLETE schedule with SPECIFIC TIMES for each activity\n"
        "- Be SPECIFIC with activity names and locations\n"
        "- Include PRACTICAL details (timing, costs if known, tips)\n"
        "- Make it ACTIONABLE - a family could follow this plan\n"
        "- Use exact times (9:00 AM, 12:30 PM, etc.)\n"
        "- Use the research to inform your suggestions\n"
    )

    import json
    user_prompt = (
        "Create an ULTRA-DETAILED, COMPREHENSIVE day-by-day itinerary.\n\n"
        "MINIMUM REQUIREMENTS:\n"
        "- 2000+ words total\n"
        "- 3-4 hotel recommendations with prices and 4-5 sentences each\n"
        "- Hour-by-hour schedule for EACH day with SPECIFIC TIMES (9:00 AM, not 'morning')\n"
        "- 6-8 activities with full details (name, cost, duration, tips)\n"
        "- 10+ pro tips organized by category\n"
        "- Specific restaurant names with why they're toddler-friendly\n\n"
        "USE THE RESEARCH DATA BELOW - extract specific prices, names, and details:\n\n"
        f"{json.dumps(context, indent=2)}\n\n"
        "DO NOT use generic phrases like 'check website' or 'various options'.\n"
        "BE SPECIFIC: Use exact names, prices, times, and locations from the research.\n"
        "EXPLAIN WHY: Every recommendation needs reasoning specific to this family.\n"
        "THINK TODDLER: All tips should be for families with toddlers (ages 1-3), not general families."
    )

    llm = ChatOpenAI(
        model="gpt-4o",
        temperature=0.5,
        max_tokens=4096,
        request_timeout=60
    )
    logger.debug("Composer invoking LLM to generate complete itinerary.")
    
    try:
        resp = llm.invoke([
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt},
        ])
        
        content = (resp.content or "").strip()
        word_count = len(content.split())
        logger.debug("Composer produced itinerary with %d characters, %d words.", len(content), word_count)

        # Ensure we have substantial content
        if len(content) < 2000:
            logger.warning("Generated itinerary seems too short, using fallback.")
            content = _generate_fallback_itinerary(facts, travel, stays, acts)

    except Exception as exc:
        logger.exception("Composer LLM invocation failed.")
        content = _generate_fallback_itinerary(facts, travel, stays, acts)

    # ===== PHASE 1: Register components from generated itinerary =====
    try:
        _parse_and_register_components(state, content, facts)

        # Update conversation context
        update_context(
            state,
            conversation_stage="plan_generated",
            current_topic="itinerary_review"
        )

        # Mark that itinerary has been presented to user
        state.setdefault("ui_flags", {})["itinerary_presented"] = True

        logger.info("‚úì Itinerary components registered successfully")
    except Exception:
        logger.exception("Failed to register components, but continuing with text output.")

    handle_ai_output(state, content)
    return state


def _generate_fallback_itinerary(facts, travel, stays, acts) -> str:
    """Generate a basic itinerary if LLM fails."""
    dest = facts.get("destination") or facts.get("destination_hint") or "your destination"
    duration = facts.get("duration_days", 2)
    
    output = f"# Your {dest} Trip Plan\n\n"
    output += f"## Overview\n"
    output += f"- From: {facts.get('origin', 'your location')}\n"
    output += f"- To: {dest}\n"
    output += f"- Duration: {duration} days\n\n"
    
    if travel.get("recommendations"):
        output += "## Getting There\n"
        output += travel["recommendations"][:500] + "\n\n"
        if travel.get("sources"):
            output += "**Resources:**\n"
            for src in travel["sources"][:3]:
                output += f"- [{src['title']}]({src['url']})\n"
            output += "\n"
    
    if stays.get("recommendations"):
        output += "## Accommodations\n"
        output += stays["recommendations"][:500] + "\n\n"
        if stays.get("sources"):
            output += "**Resources:**\n"
            for src in stays["sources"][:3]:
                output += f"- [{src['title']}]({src['url']})\n"
            output += "\n"
    
    if acts.get("recommendations"):
        output += "## Activities & Attractions\n"
        output += acts["recommendations"][:700] + "\n\n"
        if acts.get("sources"):
            output += "**Resources:**\n"
            for src in acts["sources"][:4]:
                output += f"- [{src['title']}]({src['url']})\n"
            output += "\n"
    
    output += "Let me know if you'd like me to adjust any part of this plan!"
    
    return output
    